// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Provides cubemap-based skyboxes for Bevy.
//!
//!
//!
//! Note: This is not an officially supported Google product.

use bevy::prelude::*;
use bevy::reflect::TypeUuid;
use bevy::render::pipeline::{
    BlendFactor, BlendOperation, BlendState, ColorTargetState, ColorWrite, CompareFunction,
    CullMode, DepthBiasState, DepthStencilState, FrontFace, PipelineDescriptor, PolygonMode,
    PrimitiveState, PrimitiveTopology, RenderPipeline, StencilFaceState, StencilState,
};
use bevy::render::render_graph::base::MainPass;
use bevy::render::render_graph::{base, AssetRenderResourcesNode, RenderGraph};
use bevy::render::renderer::RenderResources;
use bevy::render::shader::{asset_shader_defs_system, ShaderDefs, ShaderStage, ShaderStages};
use bevy::render::texture::TextureFormat;

/// Configures the skybox render pipeline and support for [`SkyboxMaterial`].
pub struct SkyboxPlugin;

impl Plugin for SkyboxPlugin {
    fn build(&self, app: &mut AppBuilder) {
        app.add_asset::<SkyboxMaterial>()
            .add_system_to_stage(
                CoreStage::PostUpdate,
                asset_shader_defs_system::<SkyboxMaterial>.system(),
            )
            .init_resource::<SkyboxTextureConversion>()
            .add_system(convert_skyboxes.system());
        add_skybox_graph(app.world_mut());
        add_skybox_mesh(&mut *app.world_mut().get_resource_mut().unwrap());

        // add default SkyboxMaterial
        let mut materials = app
            .world_mut()
            .get_resource_mut::<Assets<SkyboxMaterial>>()
            .unwrap();
        materials.set_untracked(
            Handle::<SkyboxMaterial>::default(),
            SkyboxMaterial {
                color: Color::PINK,
                ..Default::default()
            },
        );
    }
}

/// Bundle for spawning Skybox entities. Note that you should be able to use defaults for everything
/// besides `material`.
#[derive(Bundle)]
pub struct SkyboxBundle {
    /// Material to use for the skybox. Defaults to a garish pink. In most usage this should be the
    /// only field you need to set.
    pub material: Handle<SkyboxMaterial>,
    /// Mesh to use for the skybox. Defaults to [`SKYBOX_MESH_HANDLE`], which is a unit cube.
    pub mesh: Handle<Mesh>,
    pub main_pass: MainPass,
    pub draw: Draw,
    pub visible: Visible,
    /// Needs to be configured to use the skybox render pipeline.
    pub render_pipelines: RenderPipelines,
    /// Transform is largely irrelevant for a skybox, but still required by rendering.
    pub transform: Transform,
    /// Transform is largely irrelevant for a skybox, but still required by rendering.
    pub global_transform: GlobalTransform,
}

impl Default for SkyboxBundle {
    fn default() -> Self {
        Self {
            material: Default::default(),
            mesh: SKYBOX_MESH_HANDLE.typed(),
            main_pass: Default::default(),
            draw: Default::default(),
            visible: Default::default(),
            render_pipelines: RenderPipelines::from_pipelines(vec![RenderPipeline::new(
                SKYBOX_PIPELINE_HANDLE.typed(),
            )]),
            transform: Default::default(),
            global_transform: Default::default(),
        }
    }
}

/// Material for a Skybox.
#[derive(RenderResources, Debug, ShaderDefs, TypeUuid)]
// UUID5 generated by first creating a URL-namespaced UUID5 for
// "https://github.com/google/bevy_skybox_cubemap" (24291f52-ea01-574a-b6ae-3d8182f6086b) then using
// that as the namespace with `bevy_skybox_cubemap::SkyboxMaterial` as the name.
#[uuid = "fca7708e-57bb-5a81-977f-95b0e5202de0"]
pub struct SkyboxMaterial {
    /// Base color of the skybox. Multiplied with the color from the texture if a texture is
    /// supplied. Note that if you are using `SkyboxMaterial` without a texture, you should consider
    /// just setting the window clear color.
    pub color: Color,
    /// Texture to use for the skybox. This must be a cubemap texture.
    #[shader_def]
    pub texture: Option<Handle<Texture>>,
}

impl Default for SkyboxMaterial {
    fn default() -> Self {
        Self {
            // Set the default color to white, so when using with a texture the color doesn't impact
            // the texture color.
            color: Color::WHITE,
            texture: None,
        }
    }
}

/// Resource that manages converting texture handles to skyboxes. Helper manages converting
/// stacked 2d images to skybox-appropriate array textures. Note that if your skybox texture is in a
/// format that supports being loaded with layers, this is unnecessary, as you can just set each
/// face of the skybox to a separate layer instead of arranging them vertically in one image.
#[derive(Default)]
pub struct SkyboxTextureConversion {
    /// List of texture handles that should be skyboxes.
    handles: Vec<Handle<Texture>>,
}

impl SkyboxTextureConversion {
    /// Takes a handle to a texture whose dimensions are N wide X 6*N high, waits for it to load,
    /// and then reinterprets that texture as an array of 6 textures suitable or a skymap. This is
    /// useful if your skymap is not in a format that has layers, and should only be run once per
    /// texture.
    pub fn make_array(&mut self, handle: Handle<Texture>) {
        self.handles.push(handle);
    }
}

/// System to handle reinterpreting an Nx6N vertical texture stack as an array of textures suitable
/// for a skybox.
fn convert_skyboxes(
    mut conversions: ResMut<SkyboxTextureConversion>,
    mut textures: ResMut<Assets<Texture>>,
) {
    let mut i = 0;
    loop {
        // Check each texture in the pending queue to see if it is loaded yet.
        let (handle, texture) = match conversions.handles.get(i) {
            Some(handle) => match textures.get_mut(handle) {
                // If it's loaded, take it out of the queue.
                Some(texture) => (conversions.handles.remove(i), texture),
                None => {
                    i += 1;
                    continue;
                }
            },
            None => break,
        };

        debug!(
            "Reinterpreting as Skybox Texture {:?}: format: {:?}, len: {}, extents: {:?}",
            handle,
            texture.format,
            texture.data.len(),
            texture.size
        );
        texture.reinterpret_stacked_2d_as_array(6);
    }
}

/// Constants defining node names.
pub mod node {
    /// Node for the `SkyboxMaterial`.
    pub const SKYBOX_MATERIAL: &str = "skybox_material";
}

/// Add the render graph and pipeline for the skybox to the world.
fn add_skybox_graph(world: &mut World) {
    {
        let mut graph = world.get_resource_mut::<RenderGraph>().unwrap();
        graph.add_system_node(
            node::SKYBOX_MATERIAL,
            AssetRenderResourcesNode::<SkyboxMaterial>::new(true),
        );
        graph
            .add_node_edge(node::SKYBOX_MATERIAL, base::node::MAIN_PASS)
            .unwrap();
    }

    let pipeline = build_skybox_pipeline(&mut world.get_resource_mut::<Assets<Shader>>().unwrap());
    let mut pipelines = world
        .get_resource_mut::<Assets<PipelineDescriptor>>()
        .unwrap();
    pipelines.set_untracked(SKYBOX_PIPELINE_HANDLE, pipeline);
}

/// Handle to use to reference the skybox pipeline.
pub const SKYBOX_PIPELINE_HANDLE: HandleUntyped =
    HandleUntyped::weak_from_u64(PipelineDescriptor::TYPE_UUID, 16037920303847147810);

fn add_skybox_mesh(meshes: &mut Assets<Mesh>) {
    // Skybox mesh needs to be large enough not to get caught in the camera's near-clip plane (but
    // can otherwise be any value).
    meshes.set_untracked(SKYBOX_MESH_HANDLE, Mesh::from(shape::Cube { size: 1.0 }));
}

/// Handle to use to reference the skybox mesh.
pub const SKYBOX_MESH_HANDLE: HandleUntyped =
    HandleUntyped::weak_from_u64(Mesh::TYPE_UUID, 7423141153313829192);

/// Build the render pipeline for the skybox vertex and fragment shaders.
fn build_skybox_pipeline(shaders: &mut Assets<Shader>) -> PipelineDescriptor {
    PipelineDescriptor {
        depth_stencil: Some(DepthStencilState {
            format: TextureFormat::Depth32Float,
            depth_write_enabled: true,
            // Depth test needs to use LessEqual because it is forcing all points of the skybox to
            // maximum depth.
            depth_compare: CompareFunction::LessEqual,
            stencil: StencilState {
                front: StencilFaceState::IGNORE,
                back: StencilFaceState::IGNORE,
                read_mask: 0,
                write_mask: 0,
            },
            bias: DepthBiasState {
                constant: 0,
                slope_scale: 0.0,
                clamp: 0.0,
            },
            clamp_depth: false,
        }),
        color_target_states: vec![ColorTargetState {
            format: TextureFormat::default(),
            color_blend: BlendState {
                src_factor: BlendFactor::SrcAlpha,
                dst_factor: BlendFactor::OneMinusSrcAlpha,
                operation: BlendOperation::Add,
            },
            alpha_blend: BlendState {
                src_factor: BlendFactor::One,
                dst_factor: BlendFactor::One,
                operation: BlendOperation::Add,
            },
            write_mask: ColorWrite::ALL,
        }],
        primitive: PrimitiveState {
            topology: PrimitiveTopology::TriangleList,
            strip_index_format: None,
            front_face: FrontFace::Ccw,
            cull_mode: CullMode::Front,
            polygon_mode: PolygonMode::Fill,
        },
        ..PipelineDescriptor::new(ShaderStages {
            vertex: shaders.add(Shader::from_glsl(
                ShaderStage::Vertex,
                include_str!("skybox.vert"),
            )),
            fragment: Some(shaders.add(Shader::from_glsl(
                ShaderStage::Fragment,
                include_str!("skybox.frag"),
            ))),
        })
    }
}
